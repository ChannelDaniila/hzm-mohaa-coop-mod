//////////////////////////////////////////////
// created by chrissstrahl on 2018.06.28
// VERSION 2.00
//
// This contains the main functions for the HaZardModding Coop Mod for
// - Allied Assault
// - Breaktrough

//WARNING these files contain Adult commentary
//WARNING these files contain Adult commentary
//WARNING these files contain Adult commentary

//=========================================================================
main:{
//=========================================================================
	local.threadName = "coop_mod/main.scr::main" //[200] Smithy - used for script load checks, also can be used in future scripts

	game.ms 	= 0.0005 			//[200] Smithy - the shortest wait the game will allow (translates to 1ms)
	game.true 	= bool 1 			//[200] Smithy - nice boolean handling. will be better for engine and me.
	game.false 	= !game.true

	//[200] chrissstrahl - restore default speed
	if( int(getcvar("coop_dev")) == 1 || int(getcvar("developer")) > 0 ){ setcvar "timescale" 1 }

	$world.flags["coopHackGametIndex"]	= 0									//[200] chrissstrahl - used to
	level.gametype						= int(getCvar("g_gametype"))		//[200] chrissstrahl - have the coop mod set it just to have it work always
	level.coop_dedicated				= int(getcvar("dedicated"))		//[200] chrissstrahl - have this in a var, as we will need this more often in the future
	level.coop_svmaxclients				= int(getcvar("sv_maxclients"))
	level.coop_debugSpawn				= 0									//show (1) spawnlocations or not (0)
	level.coop_playerReady				= 0									//player(s) are not ready/not joined
	level.coop_disableSpawnWarper 		= FALSE								//[200] chrissstrahl - moved here for inizialisation

	level.coop_gametypeHackOn			= 0			//[200] chrissstrahl - used to keep track when some script commands are executed that require the gametype to be set to Singleplayer
	level.coop_gameStartedAt			= NIL		//[200] chrissstrahl - used to keep track when the first player was actually active
	level.coop_getActiveWeapon_entity	= NULL		//[200] chrissstrahl - used to retrive active weapon of player in ::getActiveWeapon, ::getActiveWeapon_detect
	level.coop_lmsAllowJoin				= 1			//[200] chrissstrahl - allow players who just enter the game to join in in lms (once any player leaves server this will be 0)
	level.coop_lmsLifes					= 0			//[200] chrissstrahl - number of lifes players have in LMS
	level.coop_musicCommandVol			= NIL
	level.coop_musicCommand				= NIL


	level.coop_cvars["developer"] = int(getcvar "developer") 					//[200] Smithy - nicer to have console variables stored in same place
	//level.coop_cvars["coop_prevMapList"] = string(getcvar "coop_prevMapList") 	//[200] Smithy - so we can reset the sv_maplist cvar is it's populated

	if(level.coop_inJeep				== NIL){ level.coop_inJeep					= 0 }		//used to check if player should be in jeep or not
	if(level.coop_playerGlueIndividual	== NIL){ level.coop_playerGlueIndividual	= 0 }		//used for replacement of $player glue (individual spots)
	if(level.coop_playerGlue			== NIL){ level.coop_playerGlue				= 0 }		//used for replacement of $player glue (glue is active)
	if(level.coop_playerHide			== NIL){ level.coop_playerHide				= 0 }		//used for replacement of $player hide
	if(level.coop_player				== NIL){ level.coop_player					= NULL }	//follow player for gloabal/fiendly.scr
	if(level.coop_playerTank			== NIL){ level.coop_playerTank				= NULL }	//tank driving player for gloabal/vehicles_thinkers.scr
	if(level.enemyhealthscalar			== NIL){ level.enemyhealthscalar			= 1 }		//health scaler - used in global/spawner.scr
	if(level.coop_noWeapon				== NIL){ level.coop_noWeapon				= 0 }		//specifies if players should have no weapons
	if(level.coop_threatbias			== NIL){ level.coop_threatbias				= 10 }		//specifies how badly the enemy considers the player a problem
	if(level.coop_aaMap					== NIL){ level.coop_aaMap					= 0 }		//sets a map to be handles like in aa
	if(level.coop_prespawn				== NIL){ level.coop_prespawn				= 1 }		//used for replace.scr::waitTillPrespawn
	if(level.coopMedicHealth			== NIL){ level.coopMedicHealth				= 1000 }	//sets medic AI health

	//[200] chrissstrahl - make sure to filter what ever is not part of the real filename
	local.fullMapName = string(getcvar("mapname"));
	level.coop_mapname = ""
	for(local.current = 0; local.current < local.fullMapName.size;local.current++){
		if(local.fullMapName[local.current] == "$"){ break }
		level.coop_mapname += local.fullMapName[local.current]
	}

	//[200] chrissstrahl - moved here to get the real mapname - fixed it now
	if(level.script	== NIL){ level.script	= "maps/"+level.coop_mapname+".scr" }

	//SINGLEPLAYER//////////////////////////
	if( level.gametype == 0 ){
		thread spWaitForPlayer
		end
	}

	setcvar "g_statefile" "coop_mod/player" 					//[200] Smithy - use different state files for coop
	waitthread initMissionNames 								//[200] Smithy - initialise the mission names and their descriptions
	thread setScoreboard 										//[200] Smithy - setup the scoreboard for this mission
	thread resetMapList 										//[200] Smithy - reset sv_maplist
	
	//MULTIPLAYER//////////////////////////
	//[200] chrissstrahl - check to load the last map on dedicated server
	if(level.gametype != 0 ){//&& level.coop_dedicated != 0
		local.lastmapname = getcvar("ui_startmap")
		if(local.lastmapname != "" && level.coop_mapname != local.lastmapname){
			exec global/missioncomplete.scr local.lastmapname
			end
		}
	}
	
    //[200] Smithy - used in coop_mod/aihandler.scr
    level.coop_actorArray["german"][1]      = NIL
    level.coop_actorArray["american"][1]    = NIL
    //if you wish to modify this later on, use 'exec coop_mod/aihandler.scr::updateTeamRunSpeed <team> <speed>'
    level.coop_aaRunSpeed["american"]       = 0.75  			//75% of SH/BT run speed - do not touch, managed in func ::updateTeamRunSpeed
    level.coop_maxPlayerScalar              = 4     			//after this number of players, stop scaling difficulty (lower number means steeper difficulty scaling)
    level.coop_actorAccuracyCalcs           = game.true     	//do dynamic enemy accuracy calculations for difficulty
    level.coop_actorPainHandler             = game.true     	//use coop method of handling pain

    //list of maps to exclude from custom pain handler
    //disguise maps should be excluded, as when in disguise the engine doesn't call pain.scr
    //omaha is excluded because it is heavily scripted with its own pain events for AI
    level.coop_painHandlerExclusions 		= "m3l1a"::"m2l2a"::"m2l2b"::"m6l1c"::"e1l3"::"e1l4"
    															//you can exclude entire games from this by using first char and wildcard *
    															//e.g to exclude all BT maps add "e*" to list
    //[200] Smithy - used in coop_mod/itemhandler.scr
    level.coop_itemHandler					= game.true		//use the coop item handler
    level.coop_healthDropFreq 				= 5 			//every num of axis deaths drop a health kit (5 is default engine behavior)
    level.coop_healthRespawnTime 			= 30 			//respawn time (seconds) for world (bsp or script) health items
	level.coop_ammoRespawnTime 				= 30 			//respawn time (seconds) for world (bsp or script) weapon and ammo items
	level.coop_retainInventory 				= game.true 	//keep all weapons from previous life
	level.coop_disableHealthItems 			= game.false	//disable all health items except for enemy drops and scripted items (those with targetnames)
	level.coop_disableAmmoItems 			= game.false 	//disable all ammo items except for scripted items (those with targetnames)

	level.coop_changeGameTypeDebug 			= game.true 	//[200] Smithy - whether or not to print debug info for changeGameType func

	thread setupServer															//chrissstrahl - inizial setup, might be deprecated
	thread managePlayers														//chrissstrahl - handles spawning, respawning spectator, generic stuff each frame
	thread coop_mod/events.scr::initialiseEvents								//[200] Smithy - initialise all events we need
	exec coop_mod/loadout.scr 													//[200] Smithy - initialises the weapon loadout array for this level - moved from itemhandler.scr
	waitthread coop_mod/spawnlocations.scr::main								//chrissstrahl - create spawnpoints for coop
	waitthread mom/mom.scr::setup "coop_mod/mom_actions.scr" 2 "coop_mom"		//chrissstrahl - set coop mod specific mom file

	level.coop_mainScriptLoaded = game.true 									//[200] Smithy - used by waitForMainScript to check if main has loaded

	//[200] Smithy - created funcs for events
	if (thread coop_mod/eventsystem.scr::isEventActive "mainScriptLoaded"){									
		println "(" local.threadName "): ***** Loaded *****. Continuing " level.coop_waitingForMainThreads " waiting threads at " level.time "..." //better reporting
		thread coop_mod/eventsystem.scr::doEvent "mainScriptLoaded" 			//[200] Smithy - used by itemhandler and aihandler (+ future scripts) to notify that main has been loaded
	}
}end

//[200] chrissstrahl - have a seperate handle for singleplayer
//=========================================================================
spWaitForPlayer:{
//=========================================================================
	level waittill spawn
	level.coop_playerReady = 1
	//[200] chrissstrahl - set variables
	$player.flags["coop_isHost"] = 1
}end

//loads next map until check is over or starting maps are reached
//this is used for unattended level loading and testing of the scripts
//this sometimes does not work as intended because of game limitations
//this is how ever much more comfortable than manual handling
//=========================================================================
coop_checkMaps:{
//=========================================================================
	if((int(getcvar("coop_dev")) == 1) && (int(getcvar("coop_diag")) == 1)){ //[200] chrissstrahl - changed to coop_diag cuz other coop mod also uses same cvar
		//[200] chrissstrahl - make sure we have at least two clients so it does not wait for player ready in loadingscreen
		if(int(getcvar("sv_maxclients")) < 2){
			setcvar "sv_maxclients" 2
		}

		//[200] chrissstrahl - if we come full circle we can stop
		if( level.coopNextMap == "briefing/briefing1" ){
			setcvar "timescale" 1 //[200] chrissstrahl - restore timescale
			setcvar "coop_diag" "0"
			end
		}
		setcvar "timescale" 3 //[200] chrissstrahl - speedup testing
		local.waittime = 5 //[200] chrissstrahl - reduced the time from 10 to 5
		for(local.i=local.waittime;local.i > 0;local.i--){
			iprintlnbold_noloc("Coop Map Ceck is active, loading next map in: "+local.i)
			wait 1

			//[200] chrissstrahl - make player autospawn
			if(local.waittime == local.i){
				thread autoSpawnHost
			}
		}
		setcvar "timescale" 10 //[200] chrissstrahl - speedup testing

		exec global/missioncomplete.scr level.coopNextMap
	}
}end

//[200] chrissstrahl - this outospawns the hosting player
//this is meant to be used for debugging/testing all maps
//=========================================================================
autoSpawnHost:{
//=========================================================================
	if(level.coop_dedicated != 0){ end }

	local.player = getentbyentnum( 0 )
	while( local.player == NULL ){
		waitframe
	}

	local.player iprint "You are being auto spawned for testing!!!" 1
	local.player stufftext ( "primarydmweapon rifle" )

	wait 0.1
	if( local.player == NULL ){ end }

	local.player stufftext ( "popmenu 0" )
	local.player stufftext ( "+attackprimary" )
	waitframe

	if(local.player == NULL){ end }

	local.player stufftext ( "-attackprimary" )
}end

//this makes sure we have all the settings set we need to operate correctly
//=========================================================================
setupServer:{
//=========================================================================
	//[200] chrissstrahl - make sure to correct value
	if( level.coop_disableSpawnWarper == 1){
		level.coop_disableSpawnWarper = TRUE
	}

	//[200] chrissstrahl - just to be sure this works
	setcvar "g_gametypestring" "HZM Coop Mod"

	//[200] Smithy
	if (level.coop_dedicated){
		if (level.gametype != 2){
			println "(coop_mod/main.scr::setupServer): ERROR: Gametype is " level.gametype " on dedicated server! Restarting..."
			thread restartMap
		}
	}else{
		if (level.gametype != 2){
			println "(coop_mod/main.scr::setupServer): Warning: Gametype is " level.gametype " on map load!"
		}
	}
	
	//[200] chrissstrahl - check if map-check should be donemoved here, moved here because of events system
	//[200] chrissstrahl - added updateServer to handle server settings changes
	//[200] chrissstrahl - added set this map as last active map for dedicated server reboot
	waitthread coop_checkMaps			
	thread updateServer
	if(level.coop_dedicated != 0){ setcvar "ui_startmap" level.coop_mapname }
}end

//chrissstrahl - this is only for temporary debug
//=========================================================================
setupServerBadSettingInfo local.setting local.message:{
//=========================================================================
	//end
	if( local.setting == 0 ){ end }
	error ("HZM COOP MOD BAD SETTING("+local.setting+"): "+local.message) 1000
}end

//=========================================================================
fixServer:{
//=========================================================================
	wait 3
	for(local.count=0;local.count<8;local.count++){
		iprintlnbold_noloc ( "=*= BAD SERVER SETTINGS, reloading map =*=" )
		wait 1
	}

	setcvar "ui_team_spawn_interval" 0 //local server
	setcvar "sv_team_spawn_interval" 0

	setcvar "g_gametype" 2
	setcvar "maxentities" 2048
	setcvar "timelimit" 0
	setcvar "fraglimit" 0
	setcvar "roundlimit" 0

	iprintlnbold_noloc ( "=*= LOADING MAP NOW =*=" )
	wait 1

	//force all players into spec to prevent players being in a team when the map is reloaded
	for (local.i = 1;local.i <= $player.size;local.i++){
		local.player = $player[local.i]
		if( local.player != NULL /*&& local.player.dmteam != "spectator" */ ) { //[200] chrissstrahl - move into spec, just to be sure it registers right
			local.player join_team ( "spectator" )
		}
	}
	waitframe

	//this is a ugly way to do this, but the best result so far
	thread loadMap level.coop_mapname game.false
}end

//forces player into allies team
//=========================================================================
forceTeam local.player:{
//=========================================================================
	if( local.player == NIL || local.player == NULL ){ end }

	local.player.flags["coop_isActive"] = 0
	local.player.flags["coop_team"] = local.player.dmteam
	waitthread resetSpawn local.player
	//local.player stufftext ( "popmenu 0" )

	//if( local.player.dmteam == "axis" ){
		thread global/throbtext.scr::throbtext "Only allies are allowed in Coop!" 5

		//local.player stufftext ( "popmenu 1;popmenu 0" )
	//}

	local.player join_team ( "allies" )
	waitframe
	local.player primarydmweapon "rifle"
	local.player pickweapon
	local.player stufftext ( "popmenu 0" )
}end

//makes player respawn at predefined spawn location, rather than the last pos player was alive
//=========================================================================
resetSpawn local.player:{
//=========================================================================
	local.player.flags["coop_respawnOrigin"] = ( 0 0 0 )
	local.player.flags["coop_respawnAngle"] = 0
	local.player.flags["coop_respawning"] = FALSE
}end


//[200] chrissstrahl - handle setup cmds for this player
//this has to be seperate here, because the
//=========================================================================
setupCmds local.player:{
//=========================================================================
	if(local.player == NIL || local.player== NULL){
		error ("coop_mod/main.scr::setupCmds Fatal - Invalid player")
		end
	}

	//we need to give the host some more time, because he is running all the scripts and calculations
	if(local.player.flags["coop_isHost"] == 1){
		wait 0.25
	}

	wait 0.5

	if(local.player == NIL || local.player== NULL){
		error ("coop_mod/main.scr::setupCmds Fatal - Invalid player")
		end
	}

	local.detectionValid = 1
	if(local.player.dmteam != "spectator"){
		local.detectionValid = 0
		//iprintlnbold_noloc("NOT VALID DETECT")
	}

	//local.player stufftext ( "tmstop" ) //[200] chrissstrahl - moved to detect.cfg
	//[200] chrissstrahl - used to detect if a player has the coop mod installed
	local.player stufftext ( "exec coop_mod/cfg/detect.cfg\n" )


	//this is used for playing current music, if the player joins mid-game
	//i suspect we only need to have one command, because tmstart/tmloop are overwriting each other
	if( level.coop_musicCommand != NIL ){
		local.player stufftext ( level.coop_musicCommand )
	}
	//this is used to set volume of current music, if the player joins mid-game
	if( level.coop_musicCommandVol != NIL ){
		local.player stufftext ( level.coop_musicCommandVol )
	}
	//this is used to set current music loop, if the player joins mid-game
	//if( level.coop_musicCommandLoop != NIL ){
		//local.player stufftext ( level.coop_musicCommandLoop )
	//}

	//check for 1 sec after this thread is started
	if(local.detectionValid != 1){
		//iprintlnbold_noloc("NOT VALID DETECT")
		end
	}

	//iprintlnbold_noloc("DETECTING")

	local.waitFrames = (1 * int(getcvar("sv_fps")))
	while(local.waitFrames > 0){
		if(local.player.dmteam == "allies"){
			//iprintlnbold_noloc("DETECTED!!!!")
			local.player.flags["coop_installed"] = 1
			end
		}
		local.waitFrames--
		waitframe
	}
}end

//=========================================================================
managePlayers:{
//=========================================================================
	//chrissstrahl
	//1. respawn players right at where they die
	//note that this might be very troublesome on some missions
	//this needs to be figured out as we go along
	////Going into spectator and then joing back in will spawn players at the default spawn
	//2. sets player max health, based on dificulty settings

	//[200] chrissstrahl - wait for a player to join the game
	level waittill spawn

	//[200] chrissstrahl - used to detect when a player leaves/joins
	local.prevPlayerCount = 0

	while(1){
		//if no player on server - also needed for dedicated servers
		if( $player == NULL || $player.size == 0 ){
			level.coop_playerReady = 0
			waitframe
			continue
		}
		//[200] chrissstrahl - used  to detect when a player leaves/joins
		local.playerCount = 0

		/* [200] Smithy - handled in playerSpawnEvent
		//chrissstrahl - if a health is specified in a cvar
		if( int(getCvar("coop_health")) > 100 ){
			level.coop_health = int(getCvar("coop_health"))
		}
		*/

		//chrissstrahl - calculate health factor based on dificulty settings
		/* Not implemented yet
		if(getcvar("coop_skill") == "Normal"){
			local.health = ( level.coop_health / 2 )
		}else if(getcvar("coop_skill") == "Hard"){
			local.health = ( level.coop_health / 4 )
		}
		*/

		//chrissstrahl - setup health
		//local.health = level.coop_health //[200] Smithy - handled in playerSpawnEvent

//warp player back to the place he was alive last
		for (local.i = 1;local.i <= $player.size;local.i++){
			local.player = $player[local.i]
			//if( local.player != NULL ){
				//[200] chrissstrahl - used for LMS to detect when a player leaves
				local.playerCount++

/////////////////////////////////////////SETUP
				if(	local.player.flags["coop_isActive"] == NIL){
//[200] chrissstrahl - LMS if not allowed to join, add deaths
					if( level.coop_lmsAllowJoin != 1){
						local.lmsLifes = level.coop_lmsLifes
						//add only deaths if lms is actually active
						if(local.lmsLifes > 0){
							local.player.flags["coop_deaths"] = local.lmsLifes
						}
					}

					//[200] chrissstrahl - detect host
					if(level.coop_dedicated == 0){
						local.entTemp = getentbyentnum( 0 )
						if(local.entTemp != NULL && local.entTemp == local.player){
							local.player.flags["coop_isHost"] = 1
						}
						else{
							local.player.flags["coop_isHost"] = 0
						}
					}

					local.player.flags["coop_iAmTruelyActive"] = 0
					local.player.flags["coop_isActive"] = 0
					local.player.flags["coop_justSpawnedDone"] = NIL
					local.player.flags["coop_team"] = "None"
					local.player.flags["coop_lastRespawn"] = -1
					local.player.flags["coop_joinedGameAt"] = level.time //[200] chrissstrahl - used for variouse checks

					//local.player max_health local.health //[200] Smithy - handled in playerSpawnEvent
					//local.player healthonly local.health
					//thread playerAttachTrigger local.player //[200] Smithy - defunct now we use playerSpawnEvent func below
					//this is used for friendly orientation see global/friendly::playernode
					local.player.fnum = -100

					//[200] chrissstrahl - handle delayed setup
					thread setupCmds local.player

					if( level.coop_playerHide ){
						local.player hide
					}

					//[200] chrissstrahl - check if physics is off
					if( level.coop_physicsOff != NIL && level.coop_physicsOff == 1){
						local.player physics_off
					}

					thread resetSpawn local.player

					/* //[200] Smithy - disguise stuff done in itemhandler now
					if( level.coop_playerHasDisguise != NIL ){
						local.player.has_disguise = level.coop_playerHasDisguise
						//local.player.is_disguised = level.coop_playerHasDisguise //this is suppose to be read only
					}
					*/
				}
/////////////////////////////////////////SPECTATOR
				if( local.player.dmteam == "spectator" ){
					local.player.flags["coop_iAmTruelyActive"] = 0
					if(	local.player.flags["coop_isActive"] != -1 ){
						local.player.flags["coop_justSpawnedDone"] = NIL
						local.player.flags["coop_team"] = local.player.dmteam
						local.player.flags["coop_isActive"] = -1
						waitthread resetSpawn local.player
						local.player unglue
						local.player threatbias ignoreme
						local.player.fnum = -100 //this is used for friendly orientation see global/friendly::playernode
					}
				}else{
					//[200] chrissstrahl - check if physics is off
					if( level.coop_physicsOff != NIL && level.coop_physicsOff == 1){
						local.player physics_off
					}
 
					thread skipWeaponSelect local.player //[200] Smithy - check if hes on a weapon menu, then do it for him

/////////////////////////////////////////ALIVE
					if( local.player.health > 0 ){
						//CHANGED TEAM/////////////////////////////////////////
						if( local.player.flags["coop_team"] != local.player.dmteam ){
							local.player.flags["coop_team"] = local.player.dmteam
							local.player.flags["coop_justSpawnedDone"] = NIL
							local.player.flags["coop_isActive"] = 0
							waitthread resetSpawn local.player

							//move player to spawn
							thread playerPlaceAtSpawn local.i
						}
						//NOT ACTIVE YET///////////////////////////////////////
						if(local.player.flags["coop_isActive"] != 1){
							//iprintlnbold_noloc("not active")
							if( local.player.flags["coop_iAmTruelyActive"] != 1 ){
								//move player to spawn
								thread playerPlaceAtSpawn local.i

								//iprintlnbold_noloc("not truely active")
								continue
							}
						//FIST ACTIVE AFTER INACTIVE - SETUP////////////////////
							//iprintlnbold_noloc("first time active")

							//[200] chrissstrahl - keep track of when first player was really actve
							if(level.coop_gameStartedAt == NIL){
								level.coop_gameStartedAt = level.time
							}

							//move player to spawn
							thread playerPlaceAtSpawn local.i

							//see if the level script has a special handling for players that just spawned
							if( local.player.flags["coop_justSpawnedDone"] == NIL ){
								local.player.flags["coop_justSpawnedDone"] = TRUE
								//[200] chrissstrahl - added trigger activator (this player)
								//[200] chrissstrahl - now using filtred level var instead of cvar
								//[200] chrissstrahl - no longer using player id in func name (use parm.other to get player)
								//thread startThread ( "maps/"+level.coop_mapname+".scr::coop_playerJustSpawned"+local.i ) (local.player)
								//
								//There are these optional functions calls:
								//- FIRST SPAWN:	coop_playerJustSpawned
								//- EACH RESPAWN:	coop_playerJustRespawned
								//- EACH DEATH:		coop_playerJustDied
								thread startThread ( "maps/"+level.coop_mapname+".scr::coop_playerJustSpawned" ) (local.player)
							}
							//local.player max_health local.health //[200] Smithy - handled in playerSpawnEvent
							//local.player healthonly local.health
							//get all items
							//local.player thread itemGetAll //[200] Smithy - defunct

							level.coop_playerReady = 1
							local.player.flags["coop_isActive"] = 1
							local.player threatbias level.coop_threatbias
							local.player solid
							local.player american
							local.player.fnum = -1 //this is used for friendly orientation see global/friendly::playernode
/* [200] Smithy - handled in itemhandler now
							if( level.coop_noWeapons ){
								thread playerTakeAll local.player
							}
*/

//TAKE SMOKE GRANADES AWAY
							//chrissstrahl - oh gosh how much I hate this stupid useless pice of shitt, useless in coop
/* [200] Smithy - done in itemhandler
							local.player take "models/weapons/M18_smoke_grenade.tik"
							local.player take "models/weapons/RDG-1_Smoke_grenade.tik"
							local.player take "models/weapons/nebelhandgranate.tik"
*/
/* //[200] Smithy - no longer needed now we have itemhandler
//FORCE PRIMARY
							if(local.player.flags["coop_specialWeaponPrimary"] != NIL){
								thread playerForcePrimary local.player local.player.flags["coop_specialWeaponPrimary"]
							}else if(level.coop_forcePrimary != NIL){
								thread playerForcePrimary local.player level.coop_forcePrimary
							}
//FORCE SECONDARY
							if(local.player.flags["coop_specialWeaponSecondary"] != NIL){
								thread playerForceSecondary local.player local.player.flags["coop_specialWeaponSecondary"]
							}else if(level.coop_forceSecondary != NIL){
								thread playerForceSecondary local.player level.coop_forceSecondary
							}
//FORCE PRIMARY
							if(local.player.flags["coop_specialInventory"] != NIL){
								thread playerForceInventory local.player local.player.flags["coop_specialInventory"]
							}else if(level.coop_forceInventory != NIL){
								thread playerForceInventory local.player level.coop_forceInventory
							}
*/
//HIDE PLAYER
							if( level.coop_playerHide ){
								local.player hide
							}

//move player to spawn
							thread playerPlaceAtSpawn local.i
//[200] chrissstrahl - handle glueing, used to be managed in replace.scr::glueHandle
							//waitthread playerGlue local.player //[200] Smithy - handled in playerSpawnEvent
//[200] CHRISSTRAHL /// LMS /// ///////////// check if player should be spectator in LMS
							thread lmsForceSpectatorHandle local.player
						}
// RESPAWNING & RESTORE /////////////////////////////////////////
						if(local.player.flags["coop_respawning"] == TRUE){
							if( level.coop_disableSpawnWarper != TRUE && vector_length( local.player.flags["coop_respawnOrigin"] ) > 10){
								thread playerMakeSolidAsap local.i
								local.player.flags["coop_lastRespawn"] = level.time //remember when we last respawned, prevent place at spawn
								local.player origin ( local.player.flags["coop_respawnOrigin"] )
								if(local.player.flags["coop_respawnAngle"] != 0){
									//need to call this delayed or it will not work most of the time in mp
									local.player thread playerFace ( 0 local.player.flags["coop_respawnAngle"] 0 )
								}
							}
							else{
								thread playerPlaceAtSpawn local.i
							}
							//[200] chrissstrahl - moved here
							local.player.flags["coop_respawning"] = FALSE
							//[200] chrissstrahl - added special handling for players that just respawned
							//
							//There are these optional functions calls:
							//- FIRST SPAWN:	coop_playerJustSpawned
							//- EACH RESPAWN:	coop_playerJustRespawned
							//- EACH DEATH:		coop_playerJustDied
							//thread startThread ( "maps/"+level.coop_mapname+".scr::coop_playerJustRespawned" ) (local.player)
						}
						else if( level.coop_disableSpawnWarper != TRUE ){
							if(	local.player.flags["coop_respawnTime"] == NIL ||
								local.player.flags["coop_respawnTime"] < (level.time + 2) ){
								local.player.flags["coop_respawnTime"] = level.time
								local.player.flags["coop_respawnOrigin"] = local.player.origin
								local.player.flags["coop_respawnAngle"] = local.player.viewangles[1]
							}
						}
						//ALLOW ONLY ALLIES//////////////////////////////////////////////
						/* //[200] Smithy - done in playerSpawnEvent now
						if( local.player.dmteam == "axis" ){
							if( local.player.flags["coop_forcedLast"] == NIL ){
								local.player.flags["coop_forcedLast"] = -10
							}
							//don't force if the game won't let us anymore
							if( (local.player.flags["coop_forcedLast"] + 3 ) < level.time ){
								thread forceTeam local.player
								local.player.flags["coop_forcedLast"] = level.time
							}else{
								local.player kill
							}
						}
						*/
					}
/////////////////////////////////////////DEAD
					else{
						local.player.flags["coop_iAmTruelyActive"] = 0
						if(	local.player.flags["coop_isActive"] != -2 ){
//[200] CHRISSTRAHL /// LMS /// ///////////// check if player should be spectator in LMS
							//handle death count
							local.deaths = local.player.flags["coop_deaths"]
							local.deaths++
							local.player.flags["coop_deaths"] = local.deaths
							
							//print info to player hud
							local.deaths = (level.coop_lmsLifes - local.deaths)
							if(local.deaths < 0){local.deaths=0}
							local.deaths = ( "You have [ " + local.deaths + " ] lifes left - LastManStanding is active!" )
							local.player iprint local.deaths 0
							
							thread lmsForceSpectatorHandle local.player

							local.player.flags["coop_isActive"] = -2
							local.player.flags["coop_justSpawnedDone"] = NIL
							local.player.flags["coop_respawning"] = TRUE

							//[200] chrissstrahl - start thread in main level-script
							//used to handle stuff when player dies
							//used to make sure player is not respawning in a vehicle or something
							//
							//There are these optional functions calls:
							//- FIRST SPAWN:	coop_playerJustSpawned
							//- EACH RESPAWN:	coop_playerJustRespawned
							//- EACH DEATH:		coop_playerJustDied
							thread startThread ( "maps/"+level.coop_mapname+".scr::coop_playerJustDied" ) (local.player)

							//local.player notarget 1
							local.player unglue
							local.player physics_on
							local.player threatbias ignoreme
							local.player.fnum = -100 //this is used for friendly orientation see global/friendly::playernode
						}
					}
				}
			//}
		}
		//[200] chrissstrahl - call player changed func if number of players changed
		if(local.prevPlayerCount != local.playerCount){
			waitthread playerCountChanged local.prevPlayerCount local.playerCount
		}

		//[200] chrissstrahl - LMS - check if condistions have changed
		waitthread lmsCheckLifes local.prevPlayerCount local.playerCount

		//[200] chrissstrahl - keep track of player count
		local.prevPlayerCount = local.playerCount
		
		waitframe //[200] Smithy - put back here (taken out of lmsCheckLifes)
	} 
}end

//[200] Smithy
//Is called from events.scr every time a player spawners.
//we can use this to efficiently replace any spawn specific code, 
//e.g. triggers that check for active players.
//along with this method + NightFall events we can decommission the main loop.
//I will be slowly moving stuff here from main loop...
//(internal use only)
//=========================================================================
playerSpawnEvent:{
//=========================================================================
	local.player = self
	if (!local.player.isSpectator){ 						//isSpectator is a built-in BT bool, more efficient than checking for dmteam string
		//---------------------// func calls here
		thread coop_mod/itemhandler.scr::managePlayerInventory 		//handle his inventory
		thread itemGetAll                                        	//give him any inv items
		thread forceValidTeam 										//force them into allies if they spawned as axis
		thread playerHealth 										//sort their health out
		thread playerGlue local.player "spawn"  					//any new players will be glued if it's needed
		//---------------------// vars here
		local.player.flags["coop_iAmTruelyActive"] = 1
		local.player.flags["coop_isAlive"] = game.true  						//he's now alive :)
		//---------------------//

		//Add anymore spawn stuff here
	}						
}end

//[200] Smithy
//called every time a player dies. this is called from events.scr,
//which in turn is called from mike_torso on KILLED state.
//I added an extra layer and put it here as it is more intuitive and
//easier to find.
//When we transition to NightFall events then they will be housed 
//with events.scr too.
//=========================================================================
playerDeathEvent:{
//=========================================================================
	local.player = self
}end

//[200] Smithy
//this is a stub. not called from anywhere yet. Will be called via events.scr
//when we set up a NightFall event for it. 
//Status: Waiting for listen server support in NightFall
//=========================================================================
playerTeamChangeEvent:{
//=========================================================================
	local.player = self
}end

//[200] Smithy
//=========================================================================
forceValidTeam:{
//=========================================================================
	local.player = self

	//while (local.player && local.player.dmteam == "axis"){
		//if (local.player.flags["coop_forcedLast"] == NIL){
		//	local.player.flags["coop_forcedLast"] = -10
		//}
		//don't force if the game won't let us anymore
		//if ((local.player.flags["coop_forcedLast"] + 3) < level.time){
		if (local.player.dmteam == "axis"){
			thread forceTeam local.player
		}
		//	local.player.flags["coop_forcedLast"] = level.time
		//}else{
		//	local.player kill
		//}
		//waitframe
	//}
}end

//[200] Smithy - the magic combination that signals he in weapon select mode :D
// -isSpectator returns true if he is anything but walking around (e.g. died, waiting for weapons etc)
//  so he doesn't have to be on spec team for that! Slightly different.
//
// -isAlive duh
//
// -dmteam he's not in TEAM spectator
//=========================================================================
skipWeaponSelect local.player:{
//=========================================================================
	//println "************ ATTEMPTING TO SKIP SELECT SCREEN ****************"
	if (local.player.isSpectator && isAlive local.player && local.player.dmteam != "spectator"){
		local.player primarydmweapon "rifle" 	//give him a random primary gun
		local.player pickweapon 				//make him pick it
		local.player stufftext ( "popmenu 0" )	//close the menu
	}
}end

//[200] Smithy - own func for giving player their health
//=========================================================================
playerHealth:
//=========================================================================
	local.player = self

	local.coop_cvarHealth = int(getCvar("coop_health"))

	if (local.coop_cvarHealth == 0){
		level.coop_health = 750
	}else{
		level.coop_health = local.coop_cvarHealth
	}

	local.player health level.coop_health //this does both max_health and healthonly for you
end				

//[200] chrissstrahl - this is called if the number of player has changed
//::managePlayers is waiting for this thread
//=========================================================================
playerCountChanged local.prevPlayerCount local.playerCount:{
//=========================================================================
	//[200] chrissstrahl - if no player left on server restart mission
	if(local.playerCount == 0){
		wait 1
		waitthread restartMap
	}

	//[200] chrissstrahl - call Smithys ai handler to update
	exec coop_mod/aihandler.scr::updateEnemyTeamDifficulty
}end

//chrissstrahl - prints a info to player hud, only each 3 sec
//bold set to 1 prints it in bold
//strictTime set to 1 does allways wait 3 sec before next message regardless if the message text has changed
//=========================================================================
printInfo local.player local.message local.bold local.strictTime:{
//=========================================================================
	if(local.player == NULL || local.message.size < 1){ end }

	//keep timelimit only if same message
	if(local.strictTime == NIL || local.strictTime != 1 ) {
		if(	local.player.flags["coop_lastInfoPrintText"] != NIL &&
			local.message == local.player.flags["coop_lastInfoPrintText"] &&
			level.time < int(local.player.flags["coop_lastInfoPrint"] + 3))
		{
			end
		}
	}
	//keep strict time limit, exit if last msg was send under 3 sec
	else if(local.player.flags["coop_lastInfoPrint"] != NIL && level.time < (int(local.player.flags["coop_lastInfoPrint"])+3)){
		end
	}

	if(local.bold == NIL){
		local.bold = 0
	}
	local.player iprint local.message local.bold
	local.player.flags["coop_lastInfoPrint"] = level.time
	local.player.flags["coop_lastInfoPrintText"] = local.message
}end

//chrissstrahl - glues a fucking stupid trigger to a player to detect if a player is active
//=========================================================================
playerAttachTrigger local.player:{
//=========================================================================
	//[200] Smithy - OK, no more 'fucking stupid triggers' and extra loop for active players - it is much nicer now :) *meditation noise*
	//this is now handled in playerSpawnEvent func above
	local.threadName = "coop_mod/main.scr::playerAttachTrigger"
	iprintlnbold_noloc("(" + local.threadName + "): Func is defunct! Fix me!")
	end

	//CODE IN THIS FUNC BELOW THIS LINE IS NOW DEFUNCT - CONSIDER REMOVING IN FUTURE <<< TODO 
/*
	if(local.player == NULL || local.player == NIL){ end }
	//iprintlnbold_noloc("playerAttachTrigger")

	if($("coop_plActDetect" + local.player.entnum) == NULL){
		local.trigger = spawn trigger_multiple targetname ("coop_plActDetect" + local.player.entnum) setthread "coop_mod/main.scr::playerActive"
		waitframe
		if(local.player == NULL){
			$("coop_plActDetect" + local.player.entnum) delete
			end
		}
	}else{
		iprintlnbold_noloc("trigger was there")
	}

	local.player.flags["coop_myActivityTriggerName"] = ("coop_plActDetect" + local.player.entnum)
	local.trigger wait 0.1
	local.trigger glue local.player

	while(local.player != NULL){
		waitframe
	}
	local.trigger delete
*/
}end

//chrissstrahl - this fixes the facing not working most of the time, can't tell what the exact cause might be
//=========================================================================
playerFace local.direction:{
//=========================================================================
	for(local.i=0;local.i<4;local.i++){
		waitframe
		if(self == NULL){
			break
		}
		self face local.direction
	}
}end

//warps all players to a specific coord
//- if local.origin is NIL players will be warped to their spawnlocations
//- if local.setSpawn set to 1 it will set this location as new spawn for all players
//
//this might need some attention, as it does not handle vehicle players - see func below: playerPlaceAtSpawn
//=========================================================================
playersWarpto local.origin local.angle local.setSpawn:{
//=========================================================================
	if(local.origin == NIL){
		for (local.pl = 1;local.pl <= $player.size;local.pl++){
			local.player =  $player[local.pl]
			if(local.player == NULL){
				continue
			}
			thread playerPlaceAtSpawn local.pl
		}
	}
	else if(local.setSpawn == 1){
		for( local.i = 1;local.i<=8;local.i++){
			if(local.angle==NIL){
				local.angle = ( 0 1 0 )
			}
			level.flags["coop_spawn"+local.i+"angles"] = ( local.angle )
			level.flags["coop_spawn"+local.i+"origin"] = ( local.origin )
		}
	}

	for (local.i = 1;local.i <= $player.size;local.i++){
		local.player =  $player[local.i]
		if(local.player == NULL){
			continue
		}
		//make sure that local.origin is set, grab origin from spawn loc
		if(local.origin == NIL){
			local.origin = level.flags["coop_spawn"+local.i+"origin"]
		}
		//elevate a little that we can use dropfloor, just in case...
		local.player origin (local.origin+(0 0 1))
		local.player droptofloor
		//clear respawn coord
		thread resetSpawn local.player

		//need to call this delayed or it will not work most of the time in mp
		if(local.angle != NIL){
			local.player thread playerFace local.angle
		}

		//make sure players don't get stuck even if there are no valid spawns
		thread playerMakeSolidAsap local.i
	}
}end

//=========================================================================
playerPlaceAtSpawn local.i:{
//=========================================================================
	//[200] chrissstrahl - if we are given a entity instead of a number, deal with it
	//detecting a single player entity as 0
	//detecting a interger as 1 or
	if(local.i == NIL){ end }
	local.varType = waitthread returnVarType local.i
	//entity - fine grab directly
	if(local.varType == 2){
		local.player = local.i
	}
	//int - grab by player number
	else if(local.varType == 4){
		local.player = $player[int(string(local.i))] //just to be sure convert to string then int, a player in a var can also be returned as a number, this is why we make sure to convert it over
	}
	//error out, it is better than never finding out whats wrong
	else{
		error ( "coop_mod/main.scr::playerPlaceAtSpawn - does not support var type: "+(waitthread returnVarTypename local.varType) ) 1000
	}

	if( local.player == NULL){ end }

	if( local.player.flags["coop_playerTankExit"] != NIL && $coop_tankExit != NULL){
		local.player origin ( $coop_tankExit.origin + (0 0 150) )
		local.player droptofloor
		if(local.player.flags["coop_isActive"] == 1){
			local.player.flags["coop_playerTankExit"] = NIL
		}
	}
	else if(level.flags["coop_spawn"+local.i+"origin"] != NIL ){
		if( (local.player.flags["coop_lastRespawn"] + 1.5) < level.time){
			local.player origin	level.flags["coop_spawn"+local.i+"origin"]

			if(level.flags["coop_spawn"+local.i+"angles"] != NIL){
				//need to call this delayed or it will not work most of the time in mp
				local.player thread playerFace level.flags["coop_spawn"+local.i+"angles"]
			}
			//if(level.coop_spawnForceState != NIL){
				//local.player forcelegsstate level.coop_spawnForceState
			//}
		}
	}
	//make sure players don't get stuck even if there are no valid spawns
	thread playerMakeSolidAsap local.i
}end

//makes a player solid as soon as it is saftly possible
//checking for other players and certain general entities
//=========================================================================
playerMakeSolidAsap local.i:{
//=========================================================================
	//println("playerMakeSolidAsap Make solid...")
	if(local.i == NIL || local.i == NULL){ end }

	local.player = NULL

	//if we are given a entity instead of a number, deal with it
	//detecting a single player entity as 0
	//detecting a interger as 1 or
	local.varType = waitthread returnVarType local.i
	//entity - fine grab directly
	if(local.varType == 2){
		local.player = local.i
	}
	//int - grab by player number
	else if(local.varType == 4){
		local.player = $player[int(string(local.i))] //just to be sure convert to string then int, a player in a var can also be returned as a number, this is why we make sure to convert it over
	}
	//error out, it is better than never finding out whats wrong
	else{
		local.typename = waitthread returnVarTypename(local.varType)
		error ( "coop_mod/main.scr::playerMakeSolidAsap - does not support var type: "+local.typename ) 1000
	}

	//run only once per player
	if(local.player.flags["coop_makesolid"] != NIL){ end }

	//println("playerMakeSolidAsap 1")

	local.player.flags["coop_makesolid"] = 1
	while( local.player != NULL && local.player.flags["coop_makesolid"] != NIL ){
		if(local.player.health <= 0){
			local.player.flags["coop_makesolid"] = NIL
			//println("playerMakeSolidAsap 2")
			end
		}
		if(level.gametype != 0){
			if(local.player.dmteam == "spectator" || local.player.flags["coop_isActive"] != 1 ){
				local.player.flags["coop_makesolid"] = NIL
				//println("playerMakeSolidAsap 3")
				end
			}
		}

		//[200] chrissstrahl - added notsolid here just to be sure the player is notsolid from the get go
		local.player notsolid

		//[200] chrissstrahl - moved here because it was in the player for loop, which is not nessary
		//check other special entites, like tanks
		if( level.coop_mapname == "m1l2b" && $tank02 != NULL && local.player isTouching $tank02){ //[200] chrissstrahl - m1l2b
			local.touch = 1
			//iprintlnbold_noloc("DEV: TOUCHING $tank02")
		}
		if( $playertank_trigger != NULL && local.player isTouching $playertank_trigger){ //king tiger tank m5l2a,m5l2a
			local.touch = 1
			//iprintlnbold_noloc("DEV: TOUCHING $playertank_trigger")
		}
		if( $panzer_mask != NULL && local.player isTouching $panzer_mask){ //german panzer m5l2a
			local.touch = 1
			//iprintlnbold_noloc("DEV: TOUCHING $panzer_mask")
		}
		if( $tank_mask != NULL && local.player isTouching $tank_mask){ //german panzer m5l1b,m5l2a
			local.touch = 1
			//iprintlnbold_noloc("DEV: TOUCHING $tank_mask")
		}
		if(level.coop_mapname == "m5l2a" && $t214 != NULL && local.player isTouching $t214){ //german strange vehicle m5l2a
			local.touch = 1
			//iprintlnbold_noloc("DEV: TOUCHING $t214")
		}
		if( $kingtigercollision != NULL && local.player isTouching $kingtigercollision ){ //king tiger m5l3
			local.touch = 1
			//iprintlnbold_noloc("DEV: TOUCHING $kingtigercollision")
		}

//[200] chrissstrahl - added additional checks
		if(local.touch){ goto playerMakeSolidAsapSet }//[200] chrissstrahl - make sure we skip unnessary checks
		if( level.coop_mapname == "m5l2a" ){
			if( $s5_tank && local.player isTouching $s5_tank){
				local.touch = 1
			}
			if( $s10_tank1 && local.player isTouching $s10_tank1){
				local.touch = 1
			}
			if( $s10_tank2 && local.player isTouching $s10_tank2){
				local.touch = 1
			}
			if( $s3_halftrak && local.player isTouching $s3_halftrak){
				local.touch = 1
			}
		}
		if($playertank && local.player istouching $playertank){
			local.touch = 1
		}
//friendlies
		if(local.touch){ goto playerMakeSolidAsapSet }//[200] chrissstrahl - make sure we skip unnessary checks
		if(isalive level.friendly1 && local.player isTouching level.friendly1){
			local.touch = 1
		}
		if(isalive level.friendly2 && local.player isTouching level.friendly2){
			local.touch = 1
		}
		if(isalive level.friendly3 && local.player isTouching level.friendly3){
			local.touch = 1
		}
		if(isalive level.friendly4 && local.player isTouching level.friendly4){
			local.touch = 1
		}
		if(isalive level.friendly5 && local.player isTouching level.friendly5){
			local.touch = 1
		}
		if(isalive level.friendly6 && local.player isTouching level.friendly6){
			local.touch = 1
		}

		//[200] chrissstrahl - apperently a goto is the best way to do this, this is so ironic
		//we have to check player vs player, otherwise the other player might still get stuck
		playerMakeSolidAsapSet:

		//check if this player is inside another
		local.touch = 0
		for (local.iOther = 1;local.iOther <= $player.size;local.iOther++){
			local.otherPlayer =  $player[local.iOther]
//check player to player - don't check the player against him self
			if(local.player == local.otherPlayer){
				continue
			}
			//if multiplayer skip player who is a spectator or not active
			if(local.otherPlayer != NULL && local.otherPlayer.health > 0){
				if( level.gametype != 0){
					if(local.otherPlayer.dmteam == "spectator" || local.otherPlayer.flags["coop_isActive"] != 1 ){
						//println("playerMakeSolidAsap 4")
						continue
					}
				}
				if(local.player isTouching local.otherPlayer){
					//println("playerMakeSolidAsap 5")
					//iprintlnbold_noloc ( "OMG, YOU DID TOUCH EACH OTHER" )
					local.otherPlayer notsolid
					thread playerMakeSolidAsap local.iOther
					local.touch = 1
				}
			}
		}

		if(local.touch == 0){
			//println("playerMakeSolidAsap NOW SOLID...")
			local.player.flags["coop_makesolid"] = NIL
			local.player solid
			end
		}
		//[200] chrissstrahl - moved notsolid here, was in each if statment seperatly before
		else{
			local.player notsolid
		}
		//println("playerMakeSolidAsap loop")
		waitframe
	}
}end

//gives all items to the player
//=========================================================================
itemGetAll:{
//=========================================================================
	if(level.coop_playerItem1 != NIL ){	self item level.coop_playerItem1 }
	if(level.coop_playerItem2 != NIL ){	self item level.coop_playerItem2 }
	if(level.coop_playerItem3 != NIL ){	self item level.coop_playerItem3 }
	if(level.coop_playerItem4 != NIL ){	self item level.coop_playerItem4 }
	if(level.coop_playerItem5 != NIL ){	self item level.coop_playerItem5 }
	if(level.coop_playerItem6 != NIL ){	self item level.coop_playerItem6 }
}end

//=========================================================================
//=========================================================================
//=========================================================================
//=========================================================================
//========================================================== FRIENDLY STUFF
//=========================================================================
//=========================================================================
//=========================================================================
//=========================================================================

//=========================================================================
friendlyPlayerOrigin:{
//=========================================================================
//return the origin of player that is currently set as ai follow target
	if( level.coop_player != NULL ){
		end level.coop_player.origin
	}
}end (0 0 0)

//set destination for ai
//=========================================================================
destination:{
//=========================================================================
	if(self == NULL){ end }

	//try to follow current follow-player
	self.destination = level.coop_player

	thread managePlayerToFollow
}end

//set tether for ai
//=========================================================================
tether:{
//=========================================================================
	if(self == NULL){ end }

	//try to leash to current follow-player
	self tether level.coop_player

	thread managePlayerToFollow
}end

//set tether for ai
//=========================================================================
managePlayerToFollow:{
//=========================================================================
	if(level.coop_managePlayerToFollow != NIL){ end }

	level.coop_managePlayerToFollow = 1
	local.grabNewPlayer = 1

	local.tries = 0
	local.triesMax = 30

	//run this loop until we decide to cancel it (probably never)
	while( level.coop_managePlayerToFollow ){

		//if everything is ok, wait a moment then try again
		if(level.coop_player != NULL && local.grabNewPlayer != 1){
			//[200] chrissstrahl - added handle for singleplayer
			if(level.gametype != 0){
				if(	level.coop_player.dmteam == "spectator" ||
					level.coop_player.health <= 0 ||
					level.coop_player.flags["coop_isActive"] != 1)
				{
					local.tries++
				}
			}else if(level.coop_player.health <= 0){
				end
			}

			//if max tries exceeded, find new player
			if(level.coop_player == NULL || local.tries >= local.triesMax){
				local.grabNewPlayer = 1
			}

			wait 1
			continue
		}

		//[200] chrissstrahl - note we can only test this once we have dedicated servers
		//level waittill playerspawn
		//
		//use the looping code below instad until we have a dedicated test server

		//pause if there is no player
		while( $player == NULL ){
			local.grabNewPlayer = 1
			wait 2
		}

		//try to find next best player to follow
		//iprintlnbold_noloc ( "find player to follow" ) //chrissstrahl
		local.grabNewPlayer = 0
		local.tries = 0
		waitthread fiendlyFindPlayer
		waitframe
	}
}end

//=========================================================================
followPlayer local.setPlayerDest:{
//=========================================================================
	error ( "coop_mod/main.scr::followPlayer - needs to be replaced with destination/tether" ) 1000
}end

//=========================================================================
followPlayerStop:{
//=========================================================================
	error ( "coop_mod/main.scr::followPlayerStop - needs to be replaced" ) 1000
	//self.flags["coop_followingPlayer"] = 0
}end

//=========================================================================
fiendlyFollow local.setPlayerDest:{
//=========================================================================
	error ( "coop_mod/main.scr::fiendlyFollow - needs to be replaced" ) 1000
	end

//update destination for ai following player
//early stage might needs more thougth with thether combined
//FOLLOW .fnum = -1
//not FOLLOW .fnum = NIL?
//update destination for ai following player
//early stage might needs more thougth with thether combined
//FOLLOW .fnum = -1
//not FOLLOW .fnum = NIL?
}end

//=========================================================================
fiendlyFindPlayer:{
//=========================================================================
	//[200] chrissstrahl - make sure this works in sp as well
	//thanks to DoubleKill for reporting this issue
	if(level.gametype == 0){
		level.coop_player = $player
		end
	}
//find a valid player to follow, this is used to direct the ai to a player to follow
	for (local.i = 1;local.i <= $player.size;local.i++){
		local.player =  $player[local.i]
		if(local.player != NULL && local.player.health > 0 && local.player.dmteam != "spectator" && local.player.flags["coop_isActive"] == 1){
			level.coop_player = local.player
			//iprintlnbold_noloc ( "player found..." + local.i + "::" + level.coop_player )
			end
		}
	}
	level.coop_player = NULL
}end

//=========================================================================
isPlayerActive local.player:{
//=========================================================================
//checks if a player is valid
	if(level.gametype == 0){
		if($player != NULL && $player.health > 0){
			end 1
		}
		//[200] chrissstrahl - fix missing end 0 if player is dead
		end 0
	}
	if( local.player == NIL ){
		error ( "coop_mod/main.scr::isPlayerActive - parameter 1 was NIL, needs to be player" ) 1000
		end 0
	}

	if( local.player != NULL ){
		if( local.player.health > 0 && local.player.dmteam != "spectator" && local.player.flags["coop_isActive"] == 1 ){
			end 1
		}
	}
}end 0

//=========================================================================
playerActives:{
//=========================================================================
	error ( "coop_mod/main.scr::playerActives - used, use player_numActive in replace.scr instead" ) 1000
	end
}end local.actives

//PLEASE NOTE! THIS FUNCTION HAS A INTENTIONAL 1 FRAME DELAY!
//=========================================================================
startThread local.script local.entity:{ //[200] chrissstrahl - add optional caller (the idea is to allow a entity to be passed)
//=========================================================================
	local.trigger = spawn trigger_once setthread local.script
	waitframe

	//[200] chrissstrahl - optional caller
	if(local.entity == NIL || local.entity == NULL || local.entity.size > 1){
		local.entity = $world
	}

	if( local.trigger != NULL ){
		if($world == NULL){error ( "coop_mod/main.scr::startThread - NO $world FOUND - FATAL ERROR" ) 1000}
		local.trigger doActivate local.entity
	}
}end

//=========================================================================
getPlayerId local.player:{
//=========================================================================
//returns $player entity number id like $player[3] returns 3
	if(level.gametype == 0){ end 1 }

	if(local.player != NULL){
		for (local.i = 1;local.i <= $player.size;local.i++){
			if( $player[local.i] == local.player ){
				end local.i
			}
		}
	}
}end NIL

//[200] chrissstrahl - used to retrive the current weapon
//[200] Smithy - TODO: remove as we don't use this anymore
//=========================================================================
getActiveWeapon_detect:{
//=========================================================================
	level.coop_getActiveWeapon_entity = self
}end

//[200] chrissstrahl - using a less resource intense method sugessted by DoubleKill
//return weapon of given player
//[200] Smithy - TODO: remove as we don't use this anymore (see itemhandler.scr::returnActiveWeapon)
//=========================================================================
getActiveWeapon local.player:{
//=========================================================================
	if(local.player != NULL && local.player.health > 0 ){
		//[200] chrissstrahl - made singleplayer compatible
		if(level.gametype == 0 || local.player.dmteam != "spectator"){
			level.coop_getActiveWeapon_entity = NULL
			local.player weaponcommand "tag_weapon_right" waitthread "getActiveWeapon_detect"
			local.ent = level.coop_getActiveWeapon_entity
			if(local.ent != NULL){
				if( waitthread isWeaponModel local.ent.model ){
					end local.ent.model
				}
			}
		}
	}
}end "weaponless"

//checks if the given model path contains the word weapons
//[200] Smithy - use already existing containsText func
//TODO: Incorporate into itemhandler.scr
//=========================================================================
isWeaponModel local.model:{
//=========================================================================
	if (waitthread coop_mod/main.scr::containsText local.model "weapons"){
		end(game.true)
	}
}end(game.false)

//Checks if the given Model is a primary Weapon
//[200] Smithy - TODO: make it part of itemhandler!
//=========================================================================
isPrimaryWeapon local.weapon:{
//=========================================================================
	if(local.weapon == "" || local.weapon == NIL){ end 0 }

	//[200] Smithy - more efficient + looks nicer
	switch (local.weapon){
		case "models/weapons/us_w_minedetector.tik":
		case "models/weapons/gr_w_minedetector.tik":
		case "models/weapons/bar.tik":
		case "models/weapons/bazooka.tik":
		case "models/weapons/kar98.tik":
		case "models/weapons/kar98sniper.tik":
		case "models/weapons/m1_garand.tik":
		case "models/weapons/mp40.tik":
		case "models/weapons/mp44.tik":
		case "models/weapons/panzerschreck.tik":
		case "models/weapons/shotgun.tik":
		case "models/weapons/springfield.tik":
		case "models/weapons/thompsonsmg.tik":
		case "models/weapons/it_w_moschetto.tik":
		case "models/weapons/it_w_breda.tik":
		case "models/weapons/uk_w_l42a1.tik":
		case "models/weapons/uk_w_piat.tik":
		case "models/weapons/uk_w_vickers.tik":
		//case "models/weapons/delisle.tik":
		case "models/weapons/enfield.tik":
		case "models/weapons/g43.tik":
		case "models/weapons/mosin_nagant_rifle.tik":
		case "models/weapons/ppsh_smg.tik":
		case "models/weapons/svt_rifle.tik":
		//case "models/weapons/it_w_beretta.tik":
		//case "models/weapons/it_w_carcano.tik":
		//case "models/weapons/nagant_revolver.tik":
		case "models/weapons/sten.tik":
		//case "models/weapons/webley_revolver.tik":
			end(game.true)
	}
}end(game.false)

//used to force a primary weapon on players
//=========================================================================
playerForcePrimary local.player local.weapon:{
//=========================================================================
	//[200] Smithy - this stuff isn't needed anymore
	iprintlnbold_noloc("main.scr::playerForcePrimary: func is defunct! Fix me!")
	end

	//TODO: remove code below this line!
	/*
	if(local.player == NULL || local.player == NIL){ end }

	//added for bt
	local.player take "models/weapons/It_W_Moschetto.tik"
	local.player take "models/weapons/It_W_Breda.tik"
	local.player take "models/weapons/US_W_MineDetector.tik"
	local.player take "models/weapons/US_W_Mine.tik"
	local.player take "models/weapons/Uk_W_L42A1.tik"
	local.player take "models/weapons/Uk_W_Piat.tik"
	local.player take "models/weapons/Uk_W_Vickers.tik"
	local.player take "models/weapons/Gr_W_MineDetector.tik"
	local.player take "models/weapons/DeLisle.tik"
	local.player take "models/weapons/enfield.tik"
	local.player take "models/weapons/G43.tik"
	local.player take "models/weapons/It_W_Carcano.tik"
	local.player take "models/weapons/kar98_mortar.tik"
	local.player take "models/weapons/Mosin_Nagant_Rifle.tik"
	local.player take "models/weapons/ppsh_smg.tik"
	local.player take "models/weapons/sten.tik"
	local.player take "models/weapons/svt_rifle.tik"

	//not sure about these
	local.player take "models/weapons/mg42portable_placed.tik"
	local.player take "models/weapons/mg42carryable.tik"

	//take all primary aa weapons
	local.player take "models/weapons/bar.tik"
	local.player take "models/weapons/bazooka.tik"
	local.player take "models/weapons/kar98.tik"
	local.player take "models/weapons/KAR98sniper.tik"
	local.player take "models/weapons/m1_garand.tik"
	local.player take "models/weapons/mp40.tik"
	local.player take "models/weapons/mp42.tik"
	local.player take "models/weapons/mp44.tik"
	local.player take "models/weapons/panzerschreck.tik"
	local.player take "models/weapons/shotgun.tik"
	local.player take "models/weapons/springfield.tik"
	local.player take "models/weapons/thompsonsmg.tik"
	waitframe

	//set new primary
	if(local.weapon != NIL){
		local.player item local.weapon
		local.player use local.weapon
	}
	*/
}end

//used to force a primary weapon on players
//=========================================================================
playerForceInventory local.player local.item:{
//=========================================================================
	//[200] Smithy - this stuff isn't needed anymore
	iprintlnbold_noloc("main.scr::playerForceInventory: func is defunct! Fix me!")
	end
	/*
	if(local.player == NULL || local.player == NIL){ end }

	//take conflicting inventory stuff
	local.player take "models/items/binoculars.tik"
	local.player take "models/items/papers.tik"
	waitframe

	//set new primary
	if(local.item != NIL){
		local.player item local.item
	}
	*/
}end

//used to force a primary weapon on players
//=========================================================================
playerForceSecondary local.player local.weapon:{
//=========================================================================
	//[200] Smithy - this stuff isn't needed anymore
	iprintlnbold_noloc("main.scr::playerForceSecondary: func is defunct! Fix me!")
	end
	/*
	if(local.player == NULL || local.player == NIL){ end }

	//bt
	local.player take "models/weapons/It_W_Beretta.tik"
	local.player take "models/weapons/Webley_Revolver.tik"
	//take all Secondary aa weapons
	local.player take "models/weapons/colt45.tik"
	local.player take "models/weapons/p38.tik"
	local.player take "models/weapons/silencedpistol.tik"
	waitframe

	//set new primary
	if(local.weapon != NIL){
		local.player item local.weapon
		local.player use local.weapon
	}
	*/
}end

//clears the primary weapon swap remember variable
//=========================================================================
playerPrimarySwapCancel local.player:{
//=========================================================================
	//[200] Smithy - this stuff isn't needed anymore
	iprintlnbold_noloc("main.scr::playerPrimarySwapCancel: func is defunct! Fix me!")
	end
	/*
	if(local.player == NULL){
		end 1
	}

	//[200] chrissstrahl - made singleplayer compatible
	if( local.player.health <= 0 ){
		end 1
	}

	//[200] chrissstrahl - made singleplayer compatible
	if(level.gametype != 0){
		if(local.player.dmteam == "spectator" || local.player.flags["coop_isActive"] != 1){
			local.player.flags["coop_swapedWeaponPrimary"] = NIL
			end 1
		}
	}
	*/
}end 0

//used to swap a primary weapon of a player with a new one, remembers the swapped weapon
//=========================================================================
playerPrimarySwap local.player local.weaponNew:{
//=========================================================================
	iprintlnbold_noloc("main.scr::playerPrimarySwap is defunct. Fix me!") //[200] Smithy
	end 																  //[200] Smithy - we won't need this now
	/*
	if(local.player == NULL || local.player == NIL ){ end }
	if( local.player.flags["coop_swapedWeaponPrimary"] == NIL && local.weaponNew != NIL){
		for(local.x=0;local.x<4;local.x++){
			for(local.y=0;local.y<4;local.y++){
				if(waitthread playerPrimarySwapCancel local.player){ end }

				if		(local.y == 0){ local.type = "heavy" }
				else if	(local.y == 1){ local.type = "smg" }
				else if	(local.y == 2){ local.type = "rifle" }
				else if	(local.y == 3){ local.type = "mg" }
				local.player useweaponclass (local.type)
				waitframe
				local.isPrimary = 0
				local.primary = waitthread getActiveWeapon local.player
				local.isPrimary = waitthread isPrimaryWeapon local.primary
				if(local.isPrimary == 1){
					local.player.flags["coop_swapedWeaponPrimary"] = local.primary
					break
				}
			}
		}
		//if no more player
		if(waitthread playerPrimarySwapCancel local.player){ end }

		//if the player still does not have a primary weapon stop right here
		if(	local.isPrimary == 0 ){
			local.player iprint ("You need a Primary Weapon in order to Trade your Weapon!") 1
			end
		}

		waitthread playerForcePrimary local.player local.weaponNew
		local.player item heavy
	}else{
		waitthread playerForcePrimary local.player local.player.flags["coop_swapedWeaponPrimary"]
		local.player.flags["coop_swapedWeaponPrimary"] = NIL
	}
	*/
}end

//checks if a string contains the given text
//=========================================================================
containsText local.source local.text:{
//=========================================================================
	if(local.source == NIL || local.text == NIL || local.source.size < local.text.size){ end 0 }

	local.index = 0
	local.match = 0
	for(local.i=0;local.i<local.source.size;local.i++){
		if(local.source[local.i] == local.text[local.index]){
			local.index++
			//match found
			if(local.index == local.text.size){
				end 1
			}
		}else{
			local.index = 0
		}
	}
}end 0

//removes the given string from the string - removes only a single char, but can be upgraded
//=========================================================================
cleanText local.source local.text:{
//=========================================================================
	if(local.source == NIL || local.text == NIL || local.source.size < local.text.size){ end local.source }
	local.newString = ""
	for(local.i=0;local.i<local.source.size;local.i++){
		if(local.source[local.i] != local.text[0]){
			local.newString += local.source[local.i]
		}
	}
}end local.newString

//return type of variable
//performs a series of checks to determine the variable type ?
//type: 0-NIL, 1-string,2-entity,3-vector,4-int/float
//-1 could not detect type
//=========================================================================
returnVarType local.var:{
//=========================================================================
	if(local.var == NIL){ end 0 }

	local.stringified = string(local.var)
	local.stringifiedSize = local.stringified.size

	//println("size:   "+local.var.size)
	//println("string: "+local.stringified)

//var is of type entity or string
	if(local.var.size == 0){
	//it can be either a empty string or a entity
		if(local.stringifiedSize == 0 ){ end 1 }
		else{ end 2 }
	}
//var is type of integer, entity or vector or singleletter string
	else if(local.var.size == 1){
		local.firstChar = string(local.stringified[0])
	//assume it is a vector if it is in brackets
		if( local.stringified[0] == "(" && local.stringified[local.stringifiedSize-1] == ")" ){
			end 3
		}
	//note: cant detect entities with a targetname < 2 chars
		if(local.stringifiedSize > 1){
		//entity targetnames never start with a number or a colon not a number will be 0 when converted
			if(	int(local.firstChar) == 0 && int(local.stringified) == 0 && local.stringified != "0.000" && local.stringified[0] != "."){
				end 2
			}

			//[200] chrissstrahl - allow this thread to be executed within 1 frame
			//no waits anywhere allow for greater usage flexibility
			local.thisIsAFloat = 0
			if( local.stringified == "0.000" ){
				local.thisIsAFloat = 1
			}else{
				if( float(local.stringified) == 0 ){
					local.thisIsAFloat = 0
				}
				else{
					local.dotAt = -1
					local.afterDot = 0
					for(local.i=0;local.i<local.stringified.size;local.i++){
						if(local.afterDot != -1){
							local.afterDot++
						}
						if(local.stringified[local.i] == "."){
							local.dotAt = local.i
							local.afterDot = 0
						}
					}
					if(local.afterDot == 3){
						local.thisIsAFloat = 1
					}
				}
			}
			if( local.thisIsAFloat == 1 || int(local.stringified) != 0){
				end 4
			}
		}else{
			if(int(local.stringified) != 0 || local.stringified == "0" || local.stringified != "0.000"){
				end 4
			}
		}
	//fallback to string
		end 1
	}
//must be a string
	else{
		end 1
	}
}end -1

//returns associated type name of type number
//=========================================================================
returnVarTypename local.var:{
//=========================================================================
	if(local.var == 1){ end "String" }
	if(local.var == 2){ end "Entity" }
	if(local.var == 3){ end "Vector" }
	if(local.var == 4){ end "Int/Float" }
}end "Unknown"

//check if it is a float, game makes sure float always has 3 digits after the dot
//=========================================================================
isFloat local.var:{
//=========================================================================
	local.stringified = string(local.var)
	if( local.stringified == "0.000" ){ end 1 }
	if( float(local.stringified) == 0 ){ end 0 }

	local.dotAt = -1
	local.afterDot = 0
	for(local.i=0;local.i<local.stringified.size;local.i++){
		if(local.afterDot != -1){
			local.afterDot++
		}
		if(local.stringified[local.i] == "."){
			local.dotAt = local.i
			local.afterDot = 0
		}
	}

	if(local.afterDot == 3){ end 1 }
}end 0

//[200] chrissstrahl - text to print if developer needs to be activated
//=========================================================================
checkCoopDeveloper local.text:{
//=========================================================================
	if(int(getcvar("coop_dev")) == 1){ end 0 }
	self iprint (local.text+" is not allowed, cvar coop_dev needs to be 1") 1
}end 1

//[200] chrissstrahl - (new) glue player to object coop handle
//[200] Smithy - uses entnum for glue spots now
//=========================================================================
playerGlue local.player local.spawn:{
//=========================================================================
	if (level.coop_playerGlue){
		if(!level.coop_playerGlueIndividual){
			local.entity = level.coop_glueTo
		}else{
			local.entity = waitthread getGlueEntity local.player					
		}

		//[200] chrissstrahl - added forcelegsstate to avoid:
		//ERROR: Stopping due to possible infinite leg state loop //e1l3 entering rowboat at level start
		//local.player forcelegsstate "STAND"
		local.player resetstate //[200] Smithy - nicer than forcing a state, also may stop torso state errors as well as leg state

		if(!local.entity){
			println "(coop_mod/main.scr::playerGlue): *ERROR* - local.entity is " local.entity " for " local.player local.player.entnum
		}else{					
			if(level.coop_glueAngle != NIL){
				local.player glue local.entity level.coop_glueAngle
			}else{
				local.player glue local.entity
			}	

			if(!level.coop_playerGlueIndividual){
				local.player notsolid
				local.player physics_off
				local.player hide
			}
		}
	}
}end

//[200] Smithy - grab his glueTo entity
//as previous spots were numbered for array index, check this and 
//provide an offset. but also allow entnum number system for any future
//glue spots. 
//=========================================================================
getGlueEntity local.player:{
//=========================================================================
	if (!$(level.coop_glueTo + "0")){
		local.offset = 1 //array index start
	}else{
		local.offset = 0 //entnum start
	}
	println "GRABBING ENT"
	println (string(level.coop_glueTo + (local.player.entnum + local.offset)))
}end($(level.coop_glueTo + (local.player.entnum + local.offset)))

//[200] Chrissstrahl - used to to check if a player should be for into spectator
//=========================================================================
lmsGetRemainingLifes local.player:{
//=========================================================================
	if(local.player == NULL){ end 0 }

	//grab values
	local.lifes = level.coop_lmsLifes
	local.deaths = local.player.flags["coop_deaths"]

	//set new value
	if(local.deaths == NIL){
		local.deaths = 0
		local.player.flags["coop_deaths"] = local.deaths		
	}
	
	//check if player is out - if value is 0 we assume LMS if OFF
	if(local.lifes > 0){
		if(local.deaths >= local.lifes){
			local.remaining = (local.lifes - local.deaths)
			if(local.remaining < 0){
				local.remaining = 0
			}
			end local.remaining
		}
	}
}end 1

//[200] Chrissstrahl - used to force a player into spectator
//=========================================================================
lmsForceSpectatorHandle local.player:{
//=========================================================================
	if(local.player.flags["lmsForceSpectatorHandleActive"] != NIL){ end }

	while(local.player != NULL){
		//check if player should be forced in spec
		if( thread lmsGetRemainingLifes local.player < 1 ){
			local.player.flags["lmsForceSpectatorHandleActive"] = 1

			//check if player already is in spec, if not force
			if(local.player.dmteam != "spectator"){
				if(local.player.health == 0){
					local.player hide
				}
				local.player.flags["coop_lmsForcedInSpectator"] = 1
				local.player spectator

				//[200] chrissstrahl - fail mission if all players are dead
				local.numActivePlayers = 0
				for (local.i = 1;local.i <= $player.size;local.i++){
					local.player = $player[local.i]
					if( local.player != NULL){
						if(local.player.flags["coop_lmsForcedInSpectator"] != 1 && local.player.dmteam != "spectator"){
							local.numActivePlayers++
						}
					}
				}
				if(local.numActivePlayers == 0){
					iprintlnbold_noloc("--")
					iprintlnbold_noloc("LMS failed all players are dead or inactive.")
					iprintlnbold_noloc("--")
					thread coop_mod/replace.scr::missionfailed
				}
			}
		}
		else{
			//if previously forced auto rejoin
			if(local.player.flags["coop_lmsForcedInSpectator"] == 1){
				local.player iprint "You are allowed back in the game!" 0
				local.player join_team ( "allies" )
			}
			local.player.flags["coop_lmsForcedInSpectator"] = NIL
			local.player.flags["lmsForceSpectatorHandleActive"] = NIL
			end
		}
		waitframe
	}
}end

//[200] Chrissstrahl - check if LMS life count has changed
//=========================================================================
lmsCheckLifes local.prevPlayerCount local.playerCount:{
//=========================================================================
//[200] chrissstrahl - LMS - check if new players should be allowed to join
	local.prevLifes = level.coop_lmsLifes
	level.coop_lmsLifes = int(getcvar("coop_lmsLifes"))
	if(level.coop_lmsLifes <= 0 ){
		level.coop_lmsLifes = 0
		level.coop_lmsAllowJoin = 1

		if(local.prevLifes != 0){
			iprintlnbold_noloc("COOP: LMS inactive - Joining allowed")
		}
	}else{
		//prevent players from reconnecting and starting over
		//effects also players that connect for the first time (we can't detect that)
		if(local.prevPlayerCount > local.playerCount){
			local.timePassed = 0
			if(level.coop_gameStartedAt != NIL){
				local.timePassed = (level.time - level.coop_gameStartedAt)
			}else{
				local.timePassed = 0
			}

			if(local.timePassed > 30){
				iprintlnbold_noloc("COOP: LMS active - No late joining")
				level.coop_lmsAllowJoin = 0
			}
		}
	}
}end

//[200] Chrissstrahl - turns g_gametype cvar hack on
//=========================================================================
hackGametypeOn local.delay:{
//=========================================================================
	if(level.gametype == 0){ end }	//no need in sp

	//get hacknumber and count up
	local.hackNumber = int($world.flags["coopHackGametIndex"])
	$world.flags["coopHackGametIndex"] = (local.hackNumber + 1)

	//if not set, set right away
	if(int(getCvar("g_gametype")) != 0){
		setcvar "g_gametype" "0"
	}

	iprintlnbold_noloc("hackGametypeOn: "+getcvar("g_gametype")+" : "+level.time)

	//flag this as active
	$world.flags[("coopHackGamet"+local.hackNumber)] = 1

	//turn off automatically if we know it has a delay
	local.flagTime = local.delayTime
	if(local.flagTime != NIL){
		thread 	hackGametypeOff local.hackNumber local.delay
	}
}end local.hackNumber

//[200] Chrissstrahl - turns g_gametype cvar hack off
//=========================================================================
hackGametypeOff local.hackNumber local.delay:{
//=========================================================================
	if(level.gametype == 0){ end }	//no need in sp

	if(local.hackNumber == NIL){
		error ( "coop_mod/main.scr::hackGametypeOff - parameter 1 was NIL should be <int> returnval of local.hNum = hackGametypeOn" ) 1000
		end
	}

	//wait provided delay time
	if(local.delay != NIL){
		wait 0.0005
	}

	//flag this as inactive
	$world.flags[("coopHackGamet"+local.hackNumber)] = 0

	local.resetGametype	= 1
	local.index			= int($world.flags["coopHackGametIndex"])

	//lets see if all hacks are done
	for(local.i=0;local.i<local.index;local.i++){
		if($world.flags[("coopHackGamet"+local.i)] != 0){
			println ("coopHackGamet"+local.i+" is 0")
			local.resetGametype = 0
		}
	}
	//all hacks are done, turn back gametype
	if(local.resetGametype){
		setcvar "g_gametype" level.gametype
	}
	iprintlnbold_noloc("hackGametypeOff: "+getcvar("g_gametype")+" : "+level.time)
}end


//[200] Smithy - changeGameType hack
//we use this whenever we want to trick game into thinking this is SP
//it lets us do disguises, sound callbacks, and other stuff
//Only one instance of this func can be run at any given time to prevent
//conflicts. as such, always use waitthread when calling it.
//Requires extra debug info for obvious reasons...
//=========================================================================
changeGameType local.gType local.wait:{
//=========================================================================
	if (level.gametype == 0){ end }

	local.threadName 		= "coop_mod/main.scr::changeGameType"
	local.prevThreadName 	= parm.previousthread.threadName
	if (local.prevThreadName == NIL){
		local.prevThreadName = "unknown location"
	}
	thread changeGameTypeDebug ("(" + local.threadName + "): Called from " + local.prevThreadName)

	//just in case we don't want any further gametype changes (e.g. map load)
	if (level.coop_preventGameTypeChanges){
		thread changeGameTypeDebug ("(" + local.threadName + "): Tried to run while gametype changes are disallowed. Stopping...")
		end
	}

	if (local.wait == NIL){ local.wait = 0 }

	//force a context switch as this function cannot run concurrently
	if (level.coop_changeGameTypeThread){
		thread changeGameTypeDebug ("(" + local.threadName + "): Tried to run concurrently at " + level.time + ". Not allowed! Waiting until changeGameType called from " + level.coop_changeGameTypeThread.prevThreadName + " has finished...")
		while (level.coop_changeGameTypeThread){ wait game.ms }
		thread changeGameTypeDebug ("(" + local.threadName + "): Thread finished at " + level.time + ". Continuing...")
		//just in case we don't want any further gametype changes (e.g. map load)
		if (level.coop_preventGameTypeChanges){
			thread changeGameTypeDebug ("(" + local.threadName + "): Tried to run while gametype changes are disallowed. Stopping...")
			end
		}
	}
	level.coop_changeGameTypeThread = local

	if (local.wait && local.wait > 0){ wait local.wait }
	setcvar "g_gametype" local.gType

	if (local.gType == 2){
		thread changeGameTypeDebug ("(" + local.threadName + "): Gametype reset to 2 after a wait of " + (local.wait * 1000.0) + "ms")
	}else{
		thread changeGameTypeDebug ("(" + local.threadName + "): Gametype temporarily changed to " + local.gType + ".")
	}
}end

//[200] Smithy - debug messages for our gametype hack
//=========================================================================
changeGameTypeDebug local.message:{
//=========================================================================
	if (level.coop_changeGameTypeDebug){ println local.message }
}end

//[200] Smithy
//used by other scripts to wait until main.scr::main has loaded.
//uses a waittill event as we cannot be sure how many instances
//will need this when, say, aihandler or itemhandler is waiting before prespawn.
//e.g. stops us having to add many, many loops for many, many BSP items.
//99% of the time this will only trigger for BSP items.
//Note: this can be used by any future scripts (use waitthread)
//=========================================================================
waitForMainScript:{
//=========================================================================
	if (level.time != 0.000){ end } //[200] Smithy 
									//fixes crashes when this func is called when server unloads map (map change, disconnect etc)...
 									//Why is it called on unload? Apparenty an object spawns and gets picked up by my itemhandler according to logs...
 									//Why does it crash? Probably because level. var that checks that main has loaded becomes uninitialised
 									//during unload procedure. So it waits here indefinitely and the game just doesn't like that.
 									//As mainScriptLoaded event is only ever needed before prespawn for bsp items, level.time will be 0.000
 									//As such, if it is not 0.000, it is an invalid call, and as such we end it here. This solves the issue.


	local.threadName 		= "coop_mod/main.scr::waitForMainScript"
	local.prevThreadName 	= parm.previousthread.threadName
	local.prevSelf 			= parm.previousthread.self 	//grab the self object the previous thread is processing for
	if (local.prevSelf){ 							 	//better reporting
		local.prevSelf = (" with object " + local.prevSelf.classname)
	}
	if (local.prevThreadName == NIL){
		local.prevThreadName = "UNKNOWN"
	}
	if (!level.coop_mainScriptLoaded){
		if (level.coop_waitingForMainThreads == NIL){		
			level.coop_waitingForMainThreads = 0 		//number of threads waiting for main to load
		}
		level.coop_waitingForMainThreads++
		println "(" local.threadName "): main.scr wasn't loaded in time for (" local.prevThreadName ") to process" local.prevSelf " at " level.time ". Thread " level.coop_waitingForMainThreads " is waiting..." //better reporting
		waitthread coop_mod/eventsystem.scr::waitTillEvent "mainScriptLoaded"
	}
}end

//[200] Smithy - use this if you want a static localised earthquake
//will affect all players in the radius
//e.g. thread coop_mod/main.scr::earthquake_local local.ent.origin 10 .4 256
//=========================================================================
earthquake_radius local.origin local.duration local.magnitude local.radius:{
//=========================================================================
	if (level.gametype == 0){ end }

	local.decay = local.magnitude / local.duration

	local.earthquake = spawn ViewJitter
	local.earthquake origin 		local.origin
	local.earthquake donedeath 		game.true 	//removes after firing
	local.earthquake edgeeffect 	1.0
	local.earthquake duration 		local.duration
	local.earthquake jitteramount 	( local.magnitude local.magnitude (local.magnitude * 1.5) )
	local.earthquake timedecay 		( local.decay  local.decay  local.decay )
	local.earthquake radius 		local.radius	
	local.earthquake triggereffect 	$world 		//do the jitter

}end

//[200] Smithy - use this if you want an earthquake to run for a specific player
//e.g. local.player thread coop_mod/main.scr::earthquake_player 10 .4
//=========================================================================
earthquake_player local.duration local.magnitude:{
//=========================================================================
	if (level.gametype == 0 || !self){ end }

	local.player = self

	local.decay = local.magnitude / local.duration

	local.earthquake = spawn ViewJitter
	local.earthquake donedeath 		game.true 			//removes after firing
	local.earthquake edgeeffect 	1.0
	local.earthquake duration 		local.duration
	local.earthquake jitteramount 	( local.magnitude local.magnitude (local.magnitude * 1.5) )
	local.earthquake timedecay 		( local.decay  local.decay  ((local.magnitude * 1.5) / local.duration))
	local.earthquake radius 		96	
	local.earthquake triggereffect 	local.player 		//do the jitter

	//attach it to player
	//i won't use glue/bind as the engine has MAX_GLUE_CHILDREN of 8 per ent and it could mess up scripts
	while (local.earthquake && isAlive local.player && local.player.dmteam != "spectator"){
		local.earthquake origin local.player.origin
		waitframe
	}

	if (local.earthquake){
		local.earthquake delete
	}
}end

//[200] Smithy - restart the current map
//=========================================================================
restartMap:{
//=========================================================================
	local.mapname = getcvar "mapname"
	//[200] chrissstrahl - i think this way it is better scalable
	if (waitthread containsText local.mapname "$"){
		local.mapname = waitthread cleanText local.mapname "$"
	}else{
		local.mapname = (local.mapname+"$")
	}
	thread loadMap local.mapname game.true
}end

//[200] Smithy - load a map
//=========================================================================
loadMap local.name local.skipFade:{
//=========================================================================
	thread disableGameTypeChanges
	//[200] chrissstrahl - lets use the default way of loading next map
	exec global/missioncomplete.scr local.lastmapname
}end

//[200] Smithy - global disabling of changeGameType hacks
//=========================================================================
disableGameTypeChanges:{
//=========================================================================
	local.threadName = "coop_mod/main.scr::disableGameTypeHacks"
	level.coop_preventGameTypeChanges = game.true 				//[200] Smithy - stop any further changes via main.scr::changeGameType if there are any
	if (level.coop_changeGameTypeThread){  						//[200] Smithy - stop the thread if one is running					
		thread changeGameTypeDebug ("(" + local.threadName + "): Terminating " + level.coop_changeGameTypeThread.threadName + " thread for level change, and stopping any future calls.")
		level.coop_changeGameTypeThread end
	}
}end

//[200] Smithy - returns the client with this entnum
//could use getentbyentnum but this is more compatible with SH
//=========================================================================
getClient local.num:{
//=========================================================================
	if ($player){
		local.maxClients = level.coop_svmaxclients
		for (local.i = 0; local.i <= local.maxClients; local.i++){
			local.index = local.i + 1
			if (!$player[local.index]){ break }
			if ($player[local.index].entnum == local.num){
				end($player[local.index])
			}
		}	
	}
}end(NULL)

//[200] Smithy - check if we are in coop or not...
//we use this for files that share both SP and MP maps
//e.g. global/ scripts
//=========================================================================
inCoopMode:{
//=========================================================================
	if (level.gametype == NIL){ level.gametype = int(getcvar "g_gametype") } //just in case level.gametype isn't a var yet

	local.isCoopMap = waitthread coop_mod/main.scr::isCoopEnabledMap (getcvar "mapname")

}end(local.isCoopMap && level.gametype)
	

//[200] Smithy - check that the map is one that supports coop mod.
//We can add custom map support to here later (e.g. 'coop_' prefix)
//=========================================================================
isCoopEnabledMap local.map:{
//=========================================================================
	//[200] chrissstrahl - lets upgrade this a bit, make sure to reduce errors
	if(local.map.size < 4){ end game.false }
	
	switch (local.map[0]){
		//missions pattern m1l,e1l,t1l
		case m:
		case e:
		case t:
			switch (local.map[2]){
				case l:
				case L:
					if( int(string(local.map[1])) > 0 ){
						end game.true						
					}
			}
		//briefings
		case b:
			if (local.map[1] == "r"){
				end(waitthread containsText local.map "iefing") //for extra efficiency we can add optional index pos as an arg
			}
		//coop_ maps
		case c:
			if(local.map[1] == "0" && local.map[2] == "0"){
				end(waitthread containsText local.map "coop_")
			}
	}
}end(game.false)

//[200] Smithy - for changing a player's FOV
//=========================================================================
changePlayerFOV local.player local.fov:{
//=========================================================================
	local.threadName = "coop_mod/main.scr::changePlayerFOV"
	local.prevCvar = getcvar "developer"
	setcvar "developer" "1"
	waitthread changeGameType 0 0
	local.player fov local.fov
	waitthread changeGameType 2 0
	setcvar "developer" local.prevCvar
}end

//[200] Smithy - stop any previously loaded scoreboard data persisting on coop maps
//also can be used to show details of current mission
//=========================================================================
setScoreboard:{
//=========================================================================
	setcvar "g_scoreboardpic" ("textures/mohmenu/dmloading/" + level.coop_mapname) //[200] chrissstrahl - added mappic as suggested
	
	//[200] chrissstrahl - break string up if it is to big
	//i wanted to do it in a seperate func, I also wanted to make it so that it detects where there is a space and if the rest fits or not
	//but my brain is to dead
	local.mapdescription = level.coop_mapDescription[level.coop_mapname]
	local.leftover = local.mapdescription.size
	local.mapdescription1 = ""
	local.mapdescription2 = ""
	local.mapdescription3 = ""
	local.currentIndex = 0
	local.maxLetters = 27

	//breake the strings up in 3 groups of 20 letters - my brain is to dead to implement word warp now
	for(local.i=local.currentIndex;local.i<(local.maxLetters * 1);local.i++){
		local.mapdescription1 += local.mapdescription[local.i]
		local.currentIndex++
		local.leftover--
		if(local.leftover==0){
			break
		}
	}
	if(local.leftover > 0){
		for(local.i=local.currentIndex;local.i<(local.maxLetters * 2);local.i++){
			local.mapdescription2 += local.mapdescription[local.i]
			local.currentIndex++
			local.leftover--
			if(local.leftover==0){
				break
			}
		}
	}
	if(local.leftover > 0){
		for(local.i=local.currentIndex;local.i<(local.maxLetters * 3);local.i++){
			local.mapdescription3 += local.mapdescription[local.i]
			local.currentIndex++
			local.leftover--
			if(local.leftover==0){
				break
			}
		}
	}
	setcvar "g_obj_alliedtext1" local.mapdescription1
	setcvar "g_obj_alliedtext2" local.mapdescription2
	setcvar "g_obj_alliedtext3" local.mapdescription3
	
	setcvar "g_obj_axistext1" ""
	setcvar "g_obj_axistext2" ""
	//[200] chrissstrahl - add info to score hud	
	setcvar "g_obj_axistext3" "www.hazardmodding.com"
}end

//[200] Smithy - used for scoreboard - can be used for other stuff if needed
//=========================================================================
initMissionNames:{
//=========================================================================
	level.coop_mapDescription["briefing1"] = "Lighting the Torch"
	level.coop_mapDescription["m1l1"] = "Rangers Lead the Way"
	level.coop_mapDescription["m1l2a"] = "The Rescue Mission"
	level.coop_mapDescription["m1l2b"] = "Sabotage the Motorpool"
	level.coop_mapDescription["m1l3a"] = "Desert Road"
	level.coop_mapDescription["m1l3b"] = "Grounding the Airfield"
	level.coop_mapDescription["m1l3c"] = "Lighthouse"
	level.coop_mapDescription["briefing2"] = "Scuttling the U-529"
	level.coop_mapDescription["m2l1"] = "Secret Documents of the Kriegsmarine"
	level.coop_mapDescription["m2l2a"] = "Naxos Prototype"
	level.coop_mapDescription["m2l2b"] = "Inside the U-529"
	level.coop_mapDescription["m2l2c"] = "Cover Blown"
	level.coop_mapDescription["m2l3"] = "Escape from Trondheim"
	level.coop_mapDescription["briefing3"] = "Operation Overlord"
	level.coop_mapDescription["m3l1a"] = "Omaha Beach - The Landing"
	level.coop_mapDescription["m3l1b"] = "Omaha Beach - Inside the Bunker"
	level.coop_mapDescription["m3l2"] = "Battle in the Bocage"
	level.coop_mapDescription["m3l3"] = "The Nebelwerfer Hunt"
	level.coop_mapDescription["briefing4"] = "Behind Enemy Lines"
	level.coop_mapDescription["m4l1"] = "Rendezvous with the Resistance"
	level.coop_mapDescription["m4l2"] = "Diverting the Enemy"
	level.coop_mapDescription["m4l3"] = "The Command Post"
	level.coop_mapDescription["briefing5"] = "Day of the Tiger"
	level.coop_mapDescription["m5l1a"] = "Sniper's Last Stand - Outskirts"
	level.coop_mapDescription["m5l1b"] = "Sniper's Last Stand - City Hall"
	level.coop_mapDescription["special"] = "Bazooka-Med"
	level.coop_mapDescription["m5l2a"] = "The Hunt for the King Tiger - Destroyed Village"
	level.coop_mapDescription["m5l2b"] = "The Hunt for the King Tiger - Country Road"
	level.coop_mapDescription["m5l3"] = "The Bridge"
	level.coop_mapDescription["briefing6"] = "The Return to Schmerzen"
	level.coop_mapDescription["m6l1a"] = "The Siegfried Forest - Flak Guns"
	level.coop_mapDescription["m6l1b"] = "The Siegfried Forest - Bunker Hill"
	level.coop_mapDescription["m6l1c"] = "Das Sturmgewehr" //[200] chrissstrahl - Bad Article, it is "Das" not "Die"
	level.coop_mapDescription["m6l2a"] = "The Communications Blackout"
	level.coop_mapDescription["m6l2b"] = "The Schmerzen Express"
	level.coop_mapDescription["m6l3a"] = "Storming Fort Schmerzen (Train platform)"
	level.coop_mapDescription["m6l3b"] = "Storming Fort Schmerzen - Inner Facility"
	level.coop_mapDescription["m6l3c"] = "Storming Fort Schmerzen - Chemical Plant"
	level.coop_mapDescription["m6l3d"] = "Storming Fort Schmerzen - Final Run"
	level.coop_mapDescription["m6l3e"] = "Storming Fort Schmerzen - Conclusion"
	
	//[200] chrissstrahl - added BT
	//Should have a maxlength of 81 or it is cut off in scoreboard
	level.coop_mapDescription["e1l1"] = "Battle of Kasserine Pass - 1"
	level.coop_mapDescription["e1l2"] = "Battle of Kasserine Pass - 2"
	level.coop_mapDescription["e1l3"] = "Operation Torch - Bizerte Fort"
	level.coop_mapDescription["e1l4"] = "Operation Torch - Bizerte Harbor"
	level.coop_mapDescription["e2l1"] = "Sicily"
	level.coop_mapDescription["e2l2"] = "Operation Husky - Caltagirone"
	level.coop_mapDescription["e2l3"] = "Operation Husky - Gela"
	level.coop_mapDescription["e3l1"] = "Invasion of Monte Cassino - 1"
	level.coop_mapDescription["e3l2"] = "Invasion of Monte Cassino - 2"
	level.coop_mapDescription["e2l3"] = "Battle of Anzio"
	level.coop_mapDescription["e2l4"] = "Battle of Monte Battaglia"
//TODO: ADD BT MISSIONS
}end

//[200] Smithy - restore a maplist if there is one
//this allows us to clear it on coop mission transition to stop mp maps
//being loaded by engine
//=========================================================================
resetMapList:{
//=========================================================================
	if (level.coop_dedicated && level.coop_cvars["coop_prevMapList"]){
		setcvar "coop_prevMapList" ""
		setcvar "sv_maplist" level.coop_cvars["coop_prevMapList"]
	}else if (!level.coop_dedicated){ //[200] Smithy - if it's a listen server, we don't need a maplist
		setcvar "sv_maplist" "" 
	}
}end


//[200] chrissstrahl - checks for changes every secound
//=========================================================================
updateServer:{
//=========================================================================
	while(1){
		wait 1
		waitthread checkForVote
		waitthread checkScoreboard
	}
}end

//[200] chrissstrahl - checks if something changed that needs to be shown in the scoreboard
//=========================================================================
checkScoreboard:{
//=========================================================================
	local.cvardata = int(getcvar("coop_health"))
	if(NIL == level.prevCoopHealth || level.coop_health != level.prevCoopHealth || local.cvardata > 0 && level.prevCoopHealth != local.cvardata){
		if(local.cvardata > 0){
			level.coop_health = local.cvardata
		}
		level.prevCoopHealth = level.coop_health
		setcvar "g_obj_axistext1" ("Health: "+level.prevCoopHealth)
	}
	
	local.cvardata = int(getcvar("coop_lmsLifes"))
	if(NIL == level.prevCoopLmsLifes || level.prevCoopLmsLifes != local.cvardata){
		level.prevCoopLmsLifes = local.cvardata
		setcvar "g_obj_axistext2" ("LMS-Lifes: "+level.prevCoopLmsLifes)
	}
}end

//[200] chrissstrahl - checks if change has been requested via vote
//=========================================================================
checkForVote:{
//=========================================================================
	local.cvarValue = getCvar("coop_callvote")
	if(local.cvarValue == ""){ end }
	
	setCvar "coop_callvote" ""
	
	if(local.cvarValue == "nextmap"){
		exec global/missioncomplete.scr level.coopNextMap 1
	}
	else if(local.cvarValue == "previousemap"){
		exec global/missioncomplete.scr level.coopPrevMap 1
	}
	else if(local.cvarValue == "restartmap"){
		thread restartMap
	}
	
	/* not working, because dedicated servers does not execute cfg from callvote
	else if(local.cvarValue == "quit"){
	//magic happens in coop_mod/cfg/sv_quit.cfg
	if(level.coop_dedicated == 0){
	iprintlnbold_noloc("--")
	iprintlnbold_noloc("Sorry - ONLY DEDICATED SERVERS CAN REBOOT")
	iprintlnbold_noloc("--")
	end
	}
	iprintlnbold_noloc("--")
	iprintlnbold_noloc("========WARNING==========")
	iprintlnbold_noloc("HZM Coop Mod will now quit and reboot the server")
	iprintlnbold_noloc("--")
	wait 3
	iprintlnbold_noloc("--")
	iprintlnbold_noloc("-- Please Reconnect ! --")
	iprintlnbold_noloc("--")
	wait 1
	if(level.coop_dedicated){
	for (local.i = 1;local.i <= $player.size;local.i++){
	local.player = $player[local.i]
	if( local.player != NULL ){
	local.player stufftext "exec coop_mod/cfg/reconnect.cfg"
	}
	}
	waitframe
	}
	}*/
}end
